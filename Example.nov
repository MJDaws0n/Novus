// Novus â€” Win32 Hello World (x86 / 32-bit)
//
// This shows the "structured assembly" idea:
// - strings + variables exist
// - you can still write raw-ish instructions
// - Win32 calls are made via extern declarations (FFI) OR raw push/call
//
// NOTE: This is a *spec/example* of what the language could look like.
// THe compiler would lower it to x86 assembly and then assemble/link into a real .exe.

module hello_win32;

// --- "Fake" import/module to represent Win32 API bindings ---
// In the real project, you'd ship a small `win32` module (or header file)
// that declares extern functions and constants.
import win32;

fn print(msg: str) -> void {
    // Add new line
    str = str + '\r\n';

    // Win32: HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);
    let h: u32 = win32.GetStdHandle(win32.STD_OUTPUT_HANDLE);

    // DWORD written = 0;
    let written: u32 = 0;

    // BOOL ok = WriteFile(h, msg.ptr, msg.len, &written, 0)
    //
    // Raw-ish stdcall sequence:
    // push lpOverlapped (NULL)
    push(0);

    // push lpNumberOfBytesWritten (&written)
    lea(eax, written);
    push(eax);

    // push nNumberOfBytesToWrite (msg.len)
    push(len(msg));

    // push lpBuffer (msg.ptr)
    lea(eax, msg);
    push(eax);

    // push hFile (h)
    push(h);

    // call WriteFile
    call(win32.WriteFile);

    ret();
}

fn main() -> i32 {
    // A string literal: compiler places it in .rdata and gives it a label.
    let msg: str = "Hello, World!";

    print(msg);

    // ExitProcess(0)
    push(0);
    call(win32.ExitProcess);

    return 0;
}