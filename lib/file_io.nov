// ---------------------------------------------------------------------------
// File I/O library for Novus (macOS Apple Silicon)
// ---------------------------------------------------------------------------

module file_io;

import standard_lib;
import standard_lib_macos_silicon;
import memory;

// ---------------------------------------------------------------------------
// File descriptor operations
// ---------------------------------------------------------------------------

fn file_open(path: str, flags: i32, mode: i32) -> i32 {
    mov(x0, path);
    mov(x1, flags);
    mov(x2, mode);
    mov(x16, 0x2000005);
    syscall();
    return u64_to_i32(getreg(x0));
}

fn file_open_read(path: str) -> i32 {
    return file_open(path, 0, 0);
}

fn file_open_write(path: str) -> i32 {
    return file_open(path, 1537, 420);
}

fn file_close(fd: i32) -> void {
    mov(x0, fd);
    mov(x16, 0x2000006);
    syscall();
}

fn file_read(fd: i32, buf_addr: u64, count: i32) -> i32 {
    mov(x0, fd);
    mov(x1, buf_addr);
    mov(x2, count);
    mov(x16, 0x2000003);
    syscall();
    return u64_to_i32(getreg(x0));
}

fn file_write(fd: i32, buf_addr: u64, count: i32) -> i32 {
    mov(x0, fd);
    mov(x1, buf_addr);
    mov(x2, count);
    mov(x16, 0x2000004);
    syscall();
    return u64_to_i32(getreg(x0));
}

fn file_write_str(fd: i32, s: str) -> i32 {
    return file_write(fd, ptr(s), len(s));
}

fn file_seek(fd: i32, offset: u64, whence: i32) -> i64 {
    mov(x0, fd);
    mov(x1, offset);
    mov(x2, whence);
    mov(x16, 0x20000C7);
    syscall();
    return getreg(x0);
}

fn file_size(fd: i32) -> u64 {
    let cur: i64 = file_seek(fd, 0, 1);
    let end: i64 = file_seek(fd, 0, 2);
    file_seek(fd, i64_to_u64(cur), 0);
    return i64_to_u64(end);
}

// ---------------------------------------------------------------------------
// Pipe helpers
// ---------------------------------------------------------------------------

fn pipe_create(res: []i32) -> void {
    mov(x16, 0x200002A);
    syscall();
    let rfd: i32 = u64_to_i32(getreg(x0));
    let wfd: i32 = u64_to_i32(getreg(x1));
    res[0] = rfd;
    res[1] = wfd;
}

fn dup2(oldfd: i32, newfd: i32) -> void {
    mov(x0, oldfd);
    mov(x1, newfd);
    mov(x16, 0x200005A);
    syscall();
}

// ---------------------------------------------------------------------------
// Path manipulation
// ---------------------------------------------------------------------------

fn path_ext(path: str) -> str {
    let plen: i32 = len(path);
    let dot: i32 = -1;
    let i: i32 = 0;
    while (i < plen) {
        if (path[i] == '.') { dot = i; }
        i = i + 1;
    }
    if (dot < 0) { return ""; }
    return substr(path, dot);
}

fn path_stem(path: str) -> str {
    let plen: i32 = len(path);
    let dot: i32 = -1;
    let i: i32 = 0;
    while (i < plen) {
        if (path[i] == '.') { dot = i; }
        i = i + 1;
    }
    if (dot < 0) { return path; }
    return substr_len(path, 0, dot);
}

fn path_insert_suffix(path: str, suffix: str) -> str {
    let stem: str = path_stem(path);
    let ext: str = path_ext(path);
    return stem + suffix + ext;
}

fn path_dir(path: str) -> str {
    let last_slash: i32 = -1;
    let i: i32 = 0;
    let slen: i32 = len(path);
    while (i < slen) {
        if (path[i] == '/') {
            last_slash = i;
        }
        i = i + 1;
    }
    if (last_slash < 0) {
        return ".";
    }
    if (last_slash == 0) {
        return "/";
    }
    return substr_len(path, 0, last_slash);
}

fn path_basename(path: str) -> str {
    let plen: i32 = len(path);
    let last_sep: i32 = -1;
    let i: i32 = 0;
    while (i < plen) {
        if (path[i] == '/') { last_sep = i; }
        i = i + 1;
    }
    if (last_sep < 0) { return path; }
    return substr(path, last_sep + 1);
}

// ---------------------------------------------------------------------------
// Directory & permission helpers
// ---------------------------------------------------------------------------

fn sys_mkdir(path: str, mode: i32) -> i32 {
    mov(x0, path);
    mov(x1, mode);
    mov(x16, 0x2000088);
    syscall();
    return u64_to_i32(getreg(x0));
}

fn sys_chmod(path: str, mode: i32) -> i32 {
    mov(x0, path);
    mov(x1, mode);
    mov(x16, 0x200000F);
    syscall();
    return u64_to_i32(getreg(x0));
}

fn file_exists(path: str) -> bool {
    mov(x0, path);
    mov(x1, 0);
    mov(x16, 0x2000021);
    syscall();
    let result: i32 = u64_to_i32(getreg(x0));
    if (result == 0) { return true; }
    return false;
}

fn file_delete(path: str) -> i32 {
    mov(x0, path);
    mov(x16, 0x200000A);
    syscall();
    return u64_to_i32(getreg(x0));
}

// ---------------------------------------------------------------------------
// Read an entire file into a string
// ---------------------------------------------------------------------------

fn read_file(path: str) -> str {
    let fd: i32 = file_open_read(path);
    if (fd < 0) { return ""; }
    let sz: u64 = file_size(fd);
    let isz: i32 = u64_to_i32(sz);
    if (isz <= 0) {
        file_close(fd);
        return "";
    }
    let buf: str = make_buffer(isz + 1);
    let nr: i32 = file_read(fd, ptr(buf), isz);
    file_close(fd);
    if (nr <= 0) { return ""; }
    return copy_bytes(ptr(buf), nr);
}

// ---------------------------------------------------------------------------
// Write a string to a file (creates or truncates)
// ---------------------------------------------------------------------------

fn write_file(path: str, content: str) -> i32 {
    let fd: i32 = file_open_write(path);
    if (fd < 0) { return -1; }
    file_write_str(fd, content);
    file_close(fd);
    return 0;
}