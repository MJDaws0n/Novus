module standard_lib_macos_silicon;

// ---------------------------------------------------------------------------
// Standard Library for Novus
// Provides common utility functions for macos on Apple Silicon (M1/M2...).
// Requires standard_lib.nov to function
// ---------------------------------------------------------------------------

import standard_lib;

fn i32_to_u64(val: i32) -> u64 {
    mov(x9, val);
    return getreg(x9);
}

fn i64_to_u64(val: i64) -> u64 {
    mov(x9, val);
    return getreg(x9);
}

fn u64_to_i64(val: u64) -> i64 {
    mov(x9, val);
    return getreg(x9);
}

fn array_len(arr: []i32) -> i32 {
    mov(x9, arr);
    let hdr: u64 = getreg(x9);
    return load32(hdr + 8);
}

fn array_len_u64(arr: []u64) -> i32 {
    mov(x9, arr);
    let hdr: u64 = getreg(x9);
    return load32(hdr + 8);
}

fn print(msg: str) -> void {
    msg = msg + "\n";
    mov(x0, 1);
    mov(x1, msg);
    mov(x2, len(msg));
    mov(x16, 0x2000004);
    syscall();
}
fn exit(code: i32) -> void {
    mov(x0, code);
    mov(x16, 0x2000001);
    syscall();
}
fn get_time_ns() -> i64 {
    // Allocate a 16-byte buffer for the timeval struct
    let buf: str = "0123456789abcdef";

    // gettimeofday(timeval *tp, timezone *tzp)
    mov(x0, buf);
    mov(x1, 0);
    mov(x16, 0x2000074);
    syscall();

    // Read back the struct fields using raw memory loads
    mov(x9, buf);
    let base: u64 = getreg(x9);
    let tv_sec: i64 = load64(base);
    let tv_usec: i64 = load64(base + 8);

    // Convert to nanoseconds: tv_sec * 1_000_000_000 + tv_usec * 1000
    return tv_sec * 1000000000 + tv_usec * 1000;
}
fn input(prompt: str, buf_len: i32 = 128) -> str {
    mov(x0, 1);
    mov(x1, prompt);
    mov(x2, len(prompt));
    mov(x16, 0x2000004);
    syscall();
    let buf: str = "";
    while(len(buf) < buf_len) {
        buf = buf + " ";
    }
    mov(x0, 0);
    mov(x1, buf);
    mov(x2, buf_len);
    mov(x16, 0x2000003);
    syscall();
    let nread: i32 = u64_to_i32(getreg(x0));
    let out: str = "";
    let i: i32 = 0;
    while (i < nread) {
        if (buf[i] == '\n') {
            break;
        }
        out = out + buf[i];
        i = i + 1;
    }
    return out;
}

// ---------------------------------------------------------------------------
// Process execution helpers (darwin/arm64)
// ---------------------------------------------------------------------------

fn ptr(s: str) -> u64 {
    mov(x9, s);
    return getreg(x9);
}

fn array_data_ptr_u64(arr: []u64) -> i64 {
    // Array heap layout: [data_ptr(8 bytes), len(8 bytes), cap(8 bytes)]
    mov(x9, arr);
    let hdr: u64 = getreg(x9);
    return load64(hdr);
}

fn execve_raw(path: str, argv: []u64) -> i32 {
    let argv_ptr: i64 = array_data_ptr_u64(argv);

    // envp: [NULL]
    let envp: []u64 = [0];
    let envp_ptr: i64 = array_data_ptr_u64(envp);

    mov(x0, path);
    mov(x1, argv_ptr);
    mov(x2, envp_ptr);

    // SYS_execve = 59
    mov(x16, 0x2000000 + 59);
    syscall();

    // If we got here, execve failed.
    return u64_to_i32(getreg(x0));
}

fn fork() -> i32 {
    // SYS_fork = 2
    // On macOS ARM64 the raw syscall returns:
    //   parent: x0 = child_pid, x1 = 0
    //   child:  x0 = child_pid, x1 = 1
    // IMPORTANT: save both registers to local vars via getreg() BEFORE
    // calling any function (like u64_to_i32) â€” function calls clobber x0/x1.
    mov(x16, 0x2000000 + 2);
    syscall();
    let raw_x0: u64 = getreg(x0);
    let raw_x1: u64 = getreg(x1);
    let x1_val: i32 = u64_to_i32(raw_x1);
    if (x1_val == 1) {
        return 0;
    }
    return u64_to_i32(raw_x0);
}

fn spawn_execve(path: str, argv: []u64) -> i32 {
    let pid: i32 = fork();
    if (pid == 0) {
        execve_raw(path, argv);
        exit(1);
        return 1;
    }
    return pid;
}